DATATYPE MOPERATION = R | W | M END;
DATATYPE ORDER = I | SC | U END;
DATATYPE BINT = I0 END;
DATATYPE TEAR_TYPE = WT | NT END;
DATATYPE BLOCK_TYPE = x END;
ADDRESS_TYPE: TYPE = SET OF INT;
MEM_OP_TYPE : TYPE = [# ID:INT, O:MOPERATION, T:TEAR_TYPE, R:ORDER, B:BLOCK_TYPE, M:ADDRESS_TYPE #];
BITUP: TYPE = [MEM_OP_TYPE, MEM_OP_TYPE];
MO_A: TYPE = ARRAY INT OF MEM_OP_TYPE;
TRTUP: TYPE = [BITUP, INT];
EV_REL: TYPE = SET OF BITUP;
EV_REL_T: TYPE = SET OF TRTUP;
THREAD_TYPE : TYPE = [# E:SET OF MEM_OP_TYPE, PO:EV_REL #];
empty_int_set: SET OF INT;
ASSERT (empty_int_set = {}:: SET OF INT);
empty_rel_set: EV_REL;
ASSERT empty_rel_set = {}:: EV_REL;
ev_set : SET OF MEM_OP_TYPE;
pair_ev_set : EV_REL;
rom_ev_set : SET OF MEM_OP_TYPE;
wom_ev_set : SET OF MEM_OP_TYPE;
locs : SET OF INT;
comp_RF : EV_REL;
comp_RBF : EV_REL_T;
SW : EV_REL;
HSW : EV_REL;
RF : EV_REL;
RBF : EV_REL_T;
HB : EV_REL;
AO : EV_REL;
MO : EV_REL;
DO : EV_REL;
ASSERT ((FORALL (e1,e2 : MEM_OP_TYPE) : (((e1,e2) IS_IN AO) => ((e1 IS_IN ev_set) AND (e2 IS_IN ev_set)))));
ASSERT ((FORALL (e1,e2 : MEM_OP_TYPE) : (((e1,e2) IS_IN DO) => ((e1 IS_IN ev_set) AND (e2 IS_IN ev_set)))));
ASSERT rom_ev_set <= ev_set;
ASSERT wom_ev_set <= ev_set;
ASSERT ((FORALL (ev : MEM_OP_TYPE) : (((ev IS_IN ev_set) AND ((ev.O = R) OR (ev.O = M))) => (ev IS_IN rom_ev_set))));
ASSERT ((FORALL (ev : MEM_OP_TYPE) : (((ev IS_IN ev_set) AND ((ev.O = W) OR (ev.O = M))) => (ev IS_IN wom_ev_set))));
en_RF: BOOLEAN;
ASSERT en_RF;
ASSERT (en_RF => (FORALL (er, ew : MEM_OP_TYPE) : (((er IS_IN ev_set) AND (ew IS_IN ev_set)) => (((TRUE) => (((er,ew) IS_IN RF) <=> (EXISTS (addr : INT) : (((addr IS_IN locs)) AND (((((er,ew),addr) IS_IN RBF)))))))))));
RF_assert : BOOLEAN;
ASSERT (RF_assert <=> (FORALL (e1,e2: MEM_OP_TYPE) : (((TRUE) AND ((e1,e2) IS_IN RF)) => (((e2.O = W) OR (e2.O = M)) AND ((e1.O = R) OR (e1.O = M))))));
ASSERT ((FORALL (t : BITUP) : ((t IS_IN RF) => (((t.0) IS_IN ev_set) AND ((t.1) IS_IN ev_set)))));
en_RBF1 : BOOLEAN;
en_RBF2 : BOOLEAN;
ASSERT en_RBF1;
ASSERT en_RBF2;
ASSERT (en_RBF1 => (FORALL (er : MEM_OP_TYPE) : (((er IS_IN rom_ev_set)) => (((TRUE) => ((FORALL (addr : INT) : (((addr IS_IN locs)) => (((addr IS_IN er.M) => (EXISTS (ew : MEM_OP_TYPE) : (((ew IS_IN wom_ev_set)) AND (((TRUE) AND ((((er,ew),addr) IS_IN RBF))))))))))))))));
ASSERT (en_RBF2 => (FORALL (er, ew1, ew2 : MEM_OP_TYPE) : (((er IS_IN ev_set) AND (ew1 IS_IN ev_set) AND (ew2 IS_IN ev_set)) => (((TRUE) => ((((er.O = R) OR (er.O = M)) AND ((ew1.O = W) OR (ew1.O = M)) AND ((ew2.O = W) OR (ew2.O = M)) AND (er.B = ew1.B) AND (er.B = ew2.B)) => (FORALL (ind : INT) : (((ind IS_IN locs)) => (((ind IS_IN er.M) => NOT((((er,ew1),ind) IS_IN RBF) AND (((er,ew2),ind) IS_IN RBF) AND NOT(ew1 = ew2))))))))))));
ASSERT ((FORALL (t : TRTUP) : ((t IS_IN RBF) => (((t.0).0 IS_IN ev_set) AND ((t.0).1 IS_IN ev_set) AND (t.1 IS_IN (t.0).0 .M) AND (t.1 IS_IN (t.0).1 .M AND (((t.0).0 .O = R) OR ((t.0).0 .O = M)) AND (((t.0).1 .O = W) OR ((t.0).1 .O = M)))))));
en_SW4 : BOOLEAN;
en_SW4c : BOOLEAN;
en_SW4di : BOOLEAN;
en_SW4d : BOOLEAN;
en_SW5 : BOOLEAN;
en_SW : BOOLEAN;
ASSERT en_SW4;
ASSERT en_SW4c;
ASSERT en_SW4di;
ASSERT en_SW4d;
ASSERT en_SW5;
ASSERT (en_SW => (FORALL (er, ew : MEM_OP_TYPE) : (((er IS_IN ev_set) AND (ew IS_IN ev_set)) => (((TRUE) => (((ew,er) IS_IN SW) <=> (((en_SW4 => ((er.R = SC) AND ((er,ew) IS_IN RF))) AND ((en_SW4c => ((ew.R = SC) AND ((er.M = ew.M) AND (er.B = ew.B)))) OR (en_SW4d => ((ew.R = I) AND (en_SW4di => (FORALL (ev : MEM_OP_TYPE) : (((ev IS_IN ev_set)) => (((TRUE) => (((er,ev) IS_IN RF) => (ev.R = I))))))))))) OR FALSE)))))));
ASSERT en_SW;
ASSERT ((FORALL (tup : BITUP) : ((tup IS_IN SW) => ((tup.0 IS_IN ev_set) AND (tup.1 IS_IN ev_set)))));
en_HB4a : BOOLEAN;
en_HB4b : BOOLEAN;
en_HB4c : BOOLEAN;
en_HB4d : BOOLEAN;
en_HB1 : BOOLEAN;
en_HB : BOOLEAN;
spo_HB : BOOLEAN;
ASSERT en_HB4a;
ASSERT en_HB4b;
ASSERT en_HB4c;
ASSERT en_HB4d;
ASSERT en_HB1;
ASSERT en_HB;
ASSERT spo_HB <=> ((HB = TCLOSURE(HB)) AND NOT(HB = empty_rel_set));
ASSERT (en_HB => (FORALL (ee, ed : MEM_OP_TYPE) : (((ee IS_IN ev_set) AND (ed IS_IN ev_set)) => (((TRUE) => (((ee,ed) IS_IN HB) <=> (NOT(ee = ed) AND ((en_HB4a => ((ee,ed) IS_IN AO)) OR (en_HB4b => ((ee,ed) IS_IN SW)) OR (en_HB4c => ((ee.R = I) AND ((NOT((ee.M & ed.M) = empty_int_set)) AND (ee.B = ed.B)))) OR (en_HB4d => (EXISTS (ef : MEM_OP_TYPE) : (((ef IS_IN ev_set)) AND (((TRUE) AND ((ee,ef) IS_IN HB) AND ((ef,ed) IS_IN HB))))))))))))));
HB_assert : BOOLEAN;
ASSERT (HB_assert <=> (FORALL (e1,e2: MEM_OP_TYPE) : ((TRUE) AND ((e1,e2) IS_IN HB) AND (e1.R = I)) => (NOT (e2.R = I))));
ASSERT ((FORALL (e1, e2 : MEM_OP_TYPE) : (((e1 IS_IN ev_set) AND (e2 IS_IN ev_set)) => (((TRUE) => (((e1,e2) IS_IN HB) => (NOT(e1 = e2))))))));
ASSERT ((FORALL (tup : BITUP) : ((tup IS_IN HB) => ((tup.0 IS_IN ev_set) AND (tup.1 IS_IN ev_set) AND NOT(tup.0 = tup.1)))));
en_CR2 : BOOLEAN;
ASSERT en_CR2;
CR : BOOLEAN;
en_CR : BOOLEAN;
ASSERT (en_CR => (CR <=> (FORALL (er : MEM_OP_TYPE) : (((er IS_IN rom_ev_set)) => (((TRUE) => (FORALL (ew : MEM_OP_TYPE) : (((ew IS_IN wom_ev_set)) => ((TRUE))))))))));
ASSERT en_CR;
OTA : BOOLEAN;
en_OTA : BOOLEAN;
ASSERT en_OTA;
en_TFR2aiiA1 : BOOLEAN;
en_TFR2aiiA : BOOLEAN;
en_TFR2aii : BOOLEAN;
en_TFR2a : BOOLEAN;
ASSERT en_TFR2aiiA1;
ASSERT en_TFR2aiiA;
ASSERT en_TFR2aii;
ASSERT en_TFR2a;
TFR : BOOLEAN;
en_TFR : BOOLEAN;
ASSERT (en_TFR => (TFR <=> (FORALL (er : MEM_OP_TYPE) : (((er IS_IN rom_ev_set)) => (((TRUE) => ((en_TFR2a => ((er.T = NT) => (en_TFR2aii => (FORALL (ew : MEM_OP_TYPE) : (((ew IS_IN ev_set)) => (((TRUE) => ((((er,ew) IS_IN RF) AND (ew.T = NT)) => (en_TFR2aiiA => ((((er.M = ew.M) AND (er.B = ew.B))) => (en_TFR2aiiA1 => (NOT (EXISTS (ev : MEM_OP_TYPE) : (((ev IS_IN ev_set)) AND (((TRUE) AND (((ev.M = ew.M) AND (ev.B = ew.B)) AND (ev.T = NT) AND (NOT (ev = ew)) AND ((er,ev) IS_IN RF)))))))))))))))))))))))));
ASSERT en_TFR;
en_MO3bii : BOOLEAN;
en_MO3b : BOOLEAN;
en_MO3a : BOOLEAN;
ASSERT en_MO3bii;
ASSERT en_MO3b;
ASSERT en_MO3a;
en_MO : BOOLEAN;
ASSERT (en_MO => (FORALL (ee, ed : MEM_OP_TYPE) : (((ee IS_IN ev_set) AND (ed IS_IN ev_set)) => (((TRUE) => ((en_MO3a => (((ee,ed) IS_IN HB) => ((ee,ed) IS_IN MO))) AND (en_MO3b => (((ee,ed) IS_IN SW) => (en_MO3bii => (NOT (EXISTS (ew : MEM_OP_TYPE) : (((ew IS_IN wom_ev_set)) AND (((TRUE) AND (((ew.M = ed.M) AND (ew.B = ed.B)) AND ((ee,ew) IS_IN MO) AND ((ew,ed) IS_IN MO))))))))))))))));
ASSERT (en_MO => (FORALL (ee : MEM_OP_TYPE) : (((ee IS_IN ev_set)) => (((TRUE) => (NOT(((ee,ee) IS_IN MO))))))));
ASSERT (en_MO => (FORALL (e1, e2 : MEM_OP_TYPE) : (((e1 IS_IN ev_set) AND (e2 IS_IN ev_set)) => (((TRUE) => ((NOT(e1 = e2) => (((e1,e2) IS_IN MO) XOR ((e2,e1) IS_IN MO)))))))));
ASSERT (en_MO => (FORALL (e1, e2, e3 : MEM_OP_TYPE) : (((e1 IS_IN ev_set) AND (e2 IS_IN ev_set) AND (e3 IS_IN ev_set)) => (((TRUE) => ((((e1,e2) IS_IN MO) AND ((e2,e3) IS_IN MO)) => ((e1,e3) IS_IN MO)))))));
ASSERT en_MO;
MO_assert : BOOLEAN;
ASSERT (MO_assert <=> (FORALL (e1,e2: MEM_OP_TYPE) : ((TRUE) AND ((e1,e2) IS_IN SW)) => ((e2.R = SC))));
ASSERT ((FORALL (tup : BITUP) : ((tup IS_IN MO) => ((tup.0 IS_IN ev_set) AND (tup.1 IS_IN ev_set)))));
SCA : BOOLEAN;
en_SCA : BOOLEAN;
ASSERT en_SCA => (SCA <=> (NOT((MO = empty_rel_set))));
ASSERT en_SCA;
VE : BOOLEAN;
en_VE : BOOLEAN;
ASSERT en_VE => (VE <=> (spo_HB AND
                         CR AND
                         TFR AND
                         SCA));
ASSERT VE;
ASSERT en_VE;
ASSERT (FORALL (ttup1, ttup2: TRTUP) : (((ttup1 IS_IN RBF) AND (ttup2 IS_IN RBF) AND (((ttup1.0).0) = ((ttup2.0).0)) AND NOT(((ttup1.0).1) = ((ttup2.0).1)) AND NOT((ttup1.1) = (ttup2.1))) => (NOT((ttup1.1) IS_IN ((ttup2.0).1).M) OR NOT((ttup2.1) IS_IN ((ttup1.0).1).M))));

ASSERT RF_assert;
ASSERT HB_assert;
ASSERT MO_assert;

CHECKSAT;